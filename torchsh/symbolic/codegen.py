from typing import Callable
import torch
from .rsh import Ylm

try:
    import sympy as sym
except ImportError:
    raise Exception(
        "Failed to import sympy\n. You need `pip install sympy` for this part of the"
        " code."
    )


x, y, z = sym.symbols("x:z", real=True)
x2, y2, z2 = sym.symbols("x2,y2,z2", real=True)

_subs = [
    {
        x**2: x2,
        y**2: y2,
        z**2: z2,
        x * y: sym.symbols("xy"),
        x * z: sym.symbols("xz"),
        y * z: sym.symbols("yz"),
    },
    {
        x2**2: sym.symbols("x4"),
        y2**2: sym.symbols("y4"),
        z2**2: sym.symbols("z4"),
    },
]

mako_tmpl = r"""
'''Real spherical harmonics in Cartesian form for PyTorch.

This is an autogenerated file. See
https://github.com/cheind/torch-spherical-harmonics
for more information.
'''

import torch

% for degree in degrees:

def rsh_cart_${degree}(xyz:torch.Tensor):
    '''Computes all real spherical harmonics up to degree ${degree}.

    This is an autogenerated method. See
    https://github.com/cheind/torch-spherical-harmonics
    for more information.

    Params:
        xyz: (N,...,3) tensor of points on the unit sphere

    Returns:
        rsh: (N,...,${(degree+1)**2}) real spherical harmonics projections of input.
    '''
% if degree > 0:
    x = xyz[...,0]
    y = xyz[...,1]
    z = xyz[...,2]
% endif

% if degree > 1:
    x2=x**2
    y2=y**2
    z2=z**2
    xy=x*y
    xz=x*z
    yz=y*z
% endif
% if degree > 3:
    x4=x2**2
    y4=y2**2
    z4=z2**2
% endif

    return torch.stack(
        [
% for n in range(degree+1):
% for instr in ynm_instr[n]:
            ${instr},
% endfor
% endfor
        ]
        ,-1
    )
% endfor
"""


def _substitute(f: sym.Expr) -> sym.Expr:
    """Substitutes pre-computed values of spherical harmonics"""
    for s in _subs:
        f = f.subs(s)
    return f


def generate_instructions_ynm(
    max_degree: int = 5, start_degree: int = 0
) -> list[list[str]]:
    """Generates PyTorch instructions for all Ynm in given range."""
    ynms = []
    for n in range(start_degree, max_degree + 1):
        level = []
        for m in range(-n, n + 1):
            ylm = Ylm(n, m, x, y, z)
            ylmstr = sym.pycode(_substitute(sym.N(ylm)))
            if n == 0:
                ylmstr = f"xyz.new_tensor({ylmstr}).expand(xyz.shape[:-1])"
            level.append(ylmstr)
        ynms.append(level)
    return ynms


def generate_source(ynm_instr: list[list[int]], degrees: list[int]) -> str:
    """Returns the source code for `rsh_cart` method defined up to given degree."""

    from mako.template import Template

    template = Template(mako_tmpl)
    content = template.render(ynm_instr=ynm_instr, degrees=degrees)
    return content


def compile_fn(degree: int) -> Callable[[torch.Tensor], torch.Tensor]:
    instr = generate_instructions_ynm(max_degree=degree)
    source = generate_source(instr, degrees=[degree])
    print(source)
    ctx = {}
    exec(source, ctx)
    return ctx[f"rsh_cart_{degree}"]


if __name__ == "__main__":
    import argparse
    import black

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o",
        "--output",
        help="Output filename. If not given, prints to stdout",
        default=None,
    )
    parser.add_argument("--max-degree", help="Maximum degree to generate", default=8)
    parser.add_argument("--min-degree", help="Minimum degree to generate", default=0)
    args = parser.parse_args()

    instr = generate_instructions_ynm(max_degree=args.max_degree)
    file = generate_source(instr, range(args.min_degree, args.max_degree + 1))
    fmt_file = black.format_file_contents(file, fast=False, mode=black.FileMode())

    if args.output:
        with open(args.output, "w") as f:
            f.write(fmt_file)
    else:
        print(fmt_file)
